// GENERATED CODE - DO NOT MODIFY BY HAND
// coverage:ignore-file
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'auth_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;
/// @nodoc
mixin _$AuthState {





@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is AuthState);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'AuthState()';
}


}

/// @nodoc
class $AuthStateCopyWith<$Res>  {
$AuthStateCopyWith(AuthState _, $Res Function(AuthState) __);
}


/// Adds pattern-matching-related methods to [AuthState].
extension AuthStatePatterns on AuthState {
/// A variant of `map` that fallback to returning `orElse`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeMap<TResult extends Object?>({TResult Function( _Initial value)?  initial,TResult Function( RegisterLoading value)?  registerLoading,TResult Function( RegisterSuccess value)?  registerSuccess,TResult Function( RegisterFailure value)?  registerFailure,TResult Function( LoginLoading value)?  loginLoading,TResult Function( LoginSuccess value)?  loginSuccess,TResult Function( LoginFailure value)?  loginFailure,TResult Function( LogoutLoading value)?  logoutLoading,TResult Function( LogoutSuccess value)?  logoutSuccess,TResult Function( LogoutFailure value)?  logoutFailure,TResult Function( BiometricLoading value)?  biometricLoading,TResult Function( BiometricSuccess value)?  biometricSuccess,TResult Function( BiometricFailure value)?  biometricFailure,TResult Function( ChangeIconVisibility value)?  changeIconVisibility,TResult Function( ChangeAppMode value)?  changeAppMode,required TResult orElse(),}){
final _that = this;
switch (_that) {
case _Initial() when initial != null:
return initial(_that);case RegisterLoading() when registerLoading != null:
return registerLoading(_that);case RegisterSuccess() when registerSuccess != null:
return registerSuccess(_that);case RegisterFailure() when registerFailure != null:
return registerFailure(_that);case LoginLoading() when loginLoading != null:
return loginLoading(_that);case LoginSuccess() when loginSuccess != null:
return loginSuccess(_that);case LoginFailure() when loginFailure != null:
return loginFailure(_that);case LogoutLoading() when logoutLoading != null:
return logoutLoading(_that);case LogoutSuccess() when logoutSuccess != null:
return logoutSuccess(_that);case LogoutFailure() when logoutFailure != null:
return logoutFailure(_that);case BiometricLoading() when biometricLoading != null:
return biometricLoading(_that);case BiometricSuccess() when biometricSuccess != null:
return biometricSuccess(_that);case BiometricFailure() when biometricFailure != null:
return biometricFailure(_that);case ChangeIconVisibility() when changeIconVisibility != null:
return changeIconVisibility(_that);case ChangeAppMode() when changeAppMode != null:
return changeAppMode(_that);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// Callbacks receives the raw object, upcasted.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case final Subclass2 value:
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult map<TResult extends Object?>({required TResult Function( _Initial value)  initial,required TResult Function( RegisterLoading value)  registerLoading,required TResult Function( RegisterSuccess value)  registerSuccess,required TResult Function( RegisterFailure value)  registerFailure,required TResult Function( LoginLoading value)  loginLoading,required TResult Function( LoginSuccess value)  loginSuccess,required TResult Function( LoginFailure value)  loginFailure,required TResult Function( LogoutLoading value)  logoutLoading,required TResult Function( LogoutSuccess value)  logoutSuccess,required TResult Function( LogoutFailure value)  logoutFailure,required TResult Function( BiometricLoading value)  biometricLoading,required TResult Function( BiometricSuccess value)  biometricSuccess,required TResult Function( BiometricFailure value)  biometricFailure,required TResult Function( ChangeIconVisibility value)  changeIconVisibility,required TResult Function( ChangeAppMode value)  changeAppMode,}){
final _that = this;
switch (_that) {
case _Initial():
return initial(_that);case RegisterLoading():
return registerLoading(_that);case RegisterSuccess():
return registerSuccess(_that);case RegisterFailure():
return registerFailure(_that);case LoginLoading():
return loginLoading(_that);case LoginSuccess():
return loginSuccess(_that);case LoginFailure():
return loginFailure(_that);case LogoutLoading():
return logoutLoading(_that);case LogoutSuccess():
return logoutSuccess(_that);case LogoutFailure():
return logoutFailure(_that);case BiometricLoading():
return biometricLoading(_that);case BiometricSuccess():
return biometricSuccess(_that);case BiometricFailure():
return biometricFailure(_that);case ChangeIconVisibility():
return changeIconVisibility(_that);case ChangeAppMode():
return changeAppMode(_that);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `map` that fallback to returning `null`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? mapOrNull<TResult extends Object?>({TResult? Function( _Initial value)?  initial,TResult? Function( RegisterLoading value)?  registerLoading,TResult? Function( RegisterSuccess value)?  registerSuccess,TResult? Function( RegisterFailure value)?  registerFailure,TResult? Function( LoginLoading value)?  loginLoading,TResult? Function( LoginSuccess value)?  loginSuccess,TResult? Function( LoginFailure value)?  loginFailure,TResult? Function( LogoutLoading value)?  logoutLoading,TResult? Function( LogoutSuccess value)?  logoutSuccess,TResult? Function( LogoutFailure value)?  logoutFailure,TResult? Function( BiometricLoading value)?  biometricLoading,TResult? Function( BiometricSuccess value)?  biometricSuccess,TResult? Function( BiometricFailure value)?  biometricFailure,TResult? Function( ChangeIconVisibility value)?  changeIconVisibility,TResult? Function( ChangeAppMode value)?  changeAppMode,}){
final _that = this;
switch (_that) {
case _Initial() when initial != null:
return initial(_that);case RegisterLoading() when registerLoading != null:
return registerLoading(_that);case RegisterSuccess() when registerSuccess != null:
return registerSuccess(_that);case RegisterFailure() when registerFailure != null:
return registerFailure(_that);case LoginLoading() when loginLoading != null:
return loginLoading(_that);case LoginSuccess() when loginSuccess != null:
return loginSuccess(_that);case LoginFailure() when loginFailure != null:
return loginFailure(_that);case LogoutLoading() when logoutLoading != null:
return logoutLoading(_that);case LogoutSuccess() when logoutSuccess != null:
return logoutSuccess(_that);case LogoutFailure() when logoutFailure != null:
return logoutFailure(_that);case BiometricLoading() when biometricLoading != null:
return biometricLoading(_that);case BiometricSuccess() when biometricSuccess != null:
return biometricSuccess(_that);case BiometricFailure() when biometricFailure != null:
return biometricFailure(_that);case ChangeIconVisibility() when changeIconVisibility != null:
return changeIconVisibility(_that);case ChangeAppMode() when changeAppMode != null:
return changeAppMode(_that);case _:
  return null;

}
}
/// A variant of `when` that fallback to an `orElse` callback.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeWhen<TResult extends Object?>({TResult Function()?  initial,TResult Function()?  registerLoading,TResult Function( UserModel user)?  registerSuccess,TResult Function( String message)?  registerFailure,TResult Function()?  loginLoading,TResult Function( UserModel user)?  loginSuccess,TResult Function( String message)?  loginFailure,TResult Function()?  logoutLoading,TResult Function()?  logoutSuccess,TResult Function( String message)?  logoutFailure,TResult Function()?  biometricLoading,TResult Function()?  biometricSuccess,TResult Function( String message)?  biometricFailure,TResult Function( bool isPassword)?  changeIconVisibility,TResult Function( bool isDark)?  changeAppMode,required TResult orElse(),}) {final _that = this;
switch (_that) {
case _Initial() when initial != null:
return initial();case RegisterLoading() when registerLoading != null:
return registerLoading();case RegisterSuccess() when registerSuccess != null:
return registerSuccess(_that.user);case RegisterFailure() when registerFailure != null:
return registerFailure(_that.message);case LoginLoading() when loginLoading != null:
return loginLoading();case LoginSuccess() when loginSuccess != null:
return loginSuccess(_that.user);case LoginFailure() when loginFailure != null:
return loginFailure(_that.message);case LogoutLoading() when logoutLoading != null:
return logoutLoading();case LogoutSuccess() when logoutSuccess != null:
return logoutSuccess();case LogoutFailure() when logoutFailure != null:
return logoutFailure(_that.message);case BiometricLoading() when biometricLoading != null:
return biometricLoading();case BiometricSuccess() when biometricSuccess != null:
return biometricSuccess();case BiometricFailure() when biometricFailure != null:
return biometricFailure(_that.message);case ChangeIconVisibility() when changeIconVisibility != null:
return changeIconVisibility(_that.isPassword);case ChangeAppMode() when changeAppMode != null:
return changeAppMode(_that.isDark);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// As opposed to `map`, this offers destructuring.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case Subclass2(:final field2):
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult when<TResult extends Object?>({required TResult Function()  initial,required TResult Function()  registerLoading,required TResult Function( UserModel user)  registerSuccess,required TResult Function( String message)  registerFailure,required TResult Function()  loginLoading,required TResult Function( UserModel user)  loginSuccess,required TResult Function( String message)  loginFailure,required TResult Function()  logoutLoading,required TResult Function()  logoutSuccess,required TResult Function( String message)  logoutFailure,required TResult Function()  biometricLoading,required TResult Function()  biometricSuccess,required TResult Function( String message)  biometricFailure,required TResult Function( bool isPassword)  changeIconVisibility,required TResult Function( bool isDark)  changeAppMode,}) {final _that = this;
switch (_that) {
case _Initial():
return initial();case RegisterLoading():
return registerLoading();case RegisterSuccess():
return registerSuccess(_that.user);case RegisterFailure():
return registerFailure(_that.message);case LoginLoading():
return loginLoading();case LoginSuccess():
return loginSuccess(_that.user);case LoginFailure():
return loginFailure(_that.message);case LogoutLoading():
return logoutLoading();case LogoutSuccess():
return logoutSuccess();case LogoutFailure():
return logoutFailure(_that.message);case BiometricLoading():
return biometricLoading();case BiometricSuccess():
return biometricSuccess();case BiometricFailure():
return biometricFailure(_that.message);case ChangeIconVisibility():
return changeIconVisibility(_that.isPassword);case ChangeAppMode():
return changeAppMode(_that.isDark);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `when` that fallback to returning `null`
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>({TResult? Function()?  initial,TResult? Function()?  registerLoading,TResult? Function( UserModel user)?  registerSuccess,TResult? Function( String message)?  registerFailure,TResult? Function()?  loginLoading,TResult? Function( UserModel user)?  loginSuccess,TResult? Function( String message)?  loginFailure,TResult? Function()?  logoutLoading,TResult? Function()?  logoutSuccess,TResult? Function( String message)?  logoutFailure,TResult? Function()?  biometricLoading,TResult? Function()?  biometricSuccess,TResult? Function( String message)?  biometricFailure,TResult? Function( bool isPassword)?  changeIconVisibility,TResult? Function( bool isDark)?  changeAppMode,}) {final _that = this;
switch (_that) {
case _Initial() when initial != null:
return initial();case RegisterLoading() when registerLoading != null:
return registerLoading();case RegisterSuccess() when registerSuccess != null:
return registerSuccess(_that.user);case RegisterFailure() when registerFailure != null:
return registerFailure(_that.message);case LoginLoading() when loginLoading != null:
return loginLoading();case LoginSuccess() when loginSuccess != null:
return loginSuccess(_that.user);case LoginFailure() when loginFailure != null:
return loginFailure(_that.message);case LogoutLoading() when logoutLoading != null:
return logoutLoading();case LogoutSuccess() when logoutSuccess != null:
return logoutSuccess();case LogoutFailure() when logoutFailure != null:
return logoutFailure(_that.message);case BiometricLoading() when biometricLoading != null:
return biometricLoading();case BiometricSuccess() when biometricSuccess != null:
return biometricSuccess();case BiometricFailure() when biometricFailure != null:
return biometricFailure(_that.message);case ChangeIconVisibility() when changeIconVisibility != null:
return changeIconVisibility(_that.isPassword);case ChangeAppMode() when changeAppMode != null:
return changeAppMode(_that.isDark);case _:
  return null;

}
}

}

/// @nodoc


class _Initial implements AuthState {
  const _Initial();
  






@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _Initial);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'AuthState.initial()';
}


}




/// @nodoc


class RegisterLoading implements AuthState {
  const RegisterLoading();
  






@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is RegisterLoading);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'AuthState.registerLoading()';
}


}




/// @nodoc


class RegisterSuccess implements AuthState {
  const RegisterSuccess(this.user);
  

 final  UserModel user;

/// Create a copy of AuthState
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$RegisterSuccessCopyWith<RegisterSuccess> get copyWith => _$RegisterSuccessCopyWithImpl<RegisterSuccess>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is RegisterSuccess&&(identical(other.user, user) || other.user == user));
}


@override
int get hashCode => Object.hash(runtimeType,user);

@override
String toString() {
  return 'AuthState.registerSuccess(user: $user)';
}


}

/// @nodoc
abstract mixin class $RegisterSuccessCopyWith<$Res> implements $AuthStateCopyWith<$Res> {
  factory $RegisterSuccessCopyWith(RegisterSuccess value, $Res Function(RegisterSuccess) _then) = _$RegisterSuccessCopyWithImpl;
@useResult
$Res call({
 UserModel user
});




}
/// @nodoc
class _$RegisterSuccessCopyWithImpl<$Res>
    implements $RegisterSuccessCopyWith<$Res> {
  _$RegisterSuccessCopyWithImpl(this._self, this._then);

  final RegisterSuccess _self;
  final $Res Function(RegisterSuccess) _then;

/// Create a copy of AuthState
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? user = null,}) {
  return _then(RegisterSuccess(
null == user ? _self.user : user // ignore: cast_nullable_to_non_nullable
as UserModel,
  ));
}


}

/// @nodoc


class RegisterFailure implements AuthState {
  const RegisterFailure(this.message);
  

 final  String message;

/// Create a copy of AuthState
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$RegisterFailureCopyWith<RegisterFailure> get copyWith => _$RegisterFailureCopyWithImpl<RegisterFailure>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is RegisterFailure&&(identical(other.message, message) || other.message == message));
}


@override
int get hashCode => Object.hash(runtimeType,message);

@override
String toString() {
  return 'AuthState.registerFailure(message: $message)';
}


}

/// @nodoc
abstract mixin class $RegisterFailureCopyWith<$Res> implements $AuthStateCopyWith<$Res> {
  factory $RegisterFailureCopyWith(RegisterFailure value, $Res Function(RegisterFailure) _then) = _$RegisterFailureCopyWithImpl;
@useResult
$Res call({
 String message
});




}
/// @nodoc
class _$RegisterFailureCopyWithImpl<$Res>
    implements $RegisterFailureCopyWith<$Res> {
  _$RegisterFailureCopyWithImpl(this._self, this._then);

  final RegisterFailure _self;
  final $Res Function(RegisterFailure) _then;

/// Create a copy of AuthState
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? message = null,}) {
  return _then(RegisterFailure(
null == message ? _self.message : message // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

/// @nodoc


class LoginLoading implements AuthState {
  const LoginLoading();
  






@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is LoginLoading);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'AuthState.loginLoading()';
}


}




/// @nodoc


class LoginSuccess implements AuthState {
  const LoginSuccess(this.user);
  

 final  UserModel user;

/// Create a copy of AuthState
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$LoginSuccessCopyWith<LoginSuccess> get copyWith => _$LoginSuccessCopyWithImpl<LoginSuccess>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is LoginSuccess&&(identical(other.user, user) || other.user == user));
}


@override
int get hashCode => Object.hash(runtimeType,user);

@override
String toString() {
  return 'AuthState.loginSuccess(user: $user)';
}


}

/// @nodoc
abstract mixin class $LoginSuccessCopyWith<$Res> implements $AuthStateCopyWith<$Res> {
  factory $LoginSuccessCopyWith(LoginSuccess value, $Res Function(LoginSuccess) _then) = _$LoginSuccessCopyWithImpl;
@useResult
$Res call({
 UserModel user
});




}
/// @nodoc
class _$LoginSuccessCopyWithImpl<$Res>
    implements $LoginSuccessCopyWith<$Res> {
  _$LoginSuccessCopyWithImpl(this._self, this._then);

  final LoginSuccess _self;
  final $Res Function(LoginSuccess) _then;

/// Create a copy of AuthState
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? user = null,}) {
  return _then(LoginSuccess(
null == user ? _self.user : user // ignore: cast_nullable_to_non_nullable
as UserModel,
  ));
}


}

/// @nodoc


class LoginFailure implements AuthState {
  const LoginFailure(this.message);
  

 final  String message;

/// Create a copy of AuthState
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$LoginFailureCopyWith<LoginFailure> get copyWith => _$LoginFailureCopyWithImpl<LoginFailure>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is LoginFailure&&(identical(other.message, message) || other.message == message));
}


@override
int get hashCode => Object.hash(runtimeType,message);

@override
String toString() {
  return 'AuthState.loginFailure(message: $message)';
}


}

/// @nodoc
abstract mixin class $LoginFailureCopyWith<$Res> implements $AuthStateCopyWith<$Res> {
  factory $LoginFailureCopyWith(LoginFailure value, $Res Function(LoginFailure) _then) = _$LoginFailureCopyWithImpl;
@useResult
$Res call({
 String message
});




}
/// @nodoc
class _$LoginFailureCopyWithImpl<$Res>
    implements $LoginFailureCopyWith<$Res> {
  _$LoginFailureCopyWithImpl(this._self, this._then);

  final LoginFailure _self;
  final $Res Function(LoginFailure) _then;

/// Create a copy of AuthState
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? message = null,}) {
  return _then(LoginFailure(
null == message ? _self.message : message // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

/// @nodoc


class LogoutLoading implements AuthState {
  const LogoutLoading();
  






@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is LogoutLoading);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'AuthState.logoutLoading()';
}


}




/// @nodoc


class LogoutSuccess implements AuthState {
  const LogoutSuccess();
  






@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is LogoutSuccess);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'AuthState.logoutSuccess()';
}


}




/// @nodoc


class LogoutFailure implements AuthState {
  const LogoutFailure(this.message);
  

 final  String message;

/// Create a copy of AuthState
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$LogoutFailureCopyWith<LogoutFailure> get copyWith => _$LogoutFailureCopyWithImpl<LogoutFailure>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is LogoutFailure&&(identical(other.message, message) || other.message == message));
}


@override
int get hashCode => Object.hash(runtimeType,message);

@override
String toString() {
  return 'AuthState.logoutFailure(message: $message)';
}


}

/// @nodoc
abstract mixin class $LogoutFailureCopyWith<$Res> implements $AuthStateCopyWith<$Res> {
  factory $LogoutFailureCopyWith(LogoutFailure value, $Res Function(LogoutFailure) _then) = _$LogoutFailureCopyWithImpl;
@useResult
$Res call({
 String message
});




}
/// @nodoc
class _$LogoutFailureCopyWithImpl<$Res>
    implements $LogoutFailureCopyWith<$Res> {
  _$LogoutFailureCopyWithImpl(this._self, this._then);

  final LogoutFailure _self;
  final $Res Function(LogoutFailure) _then;

/// Create a copy of AuthState
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? message = null,}) {
  return _then(LogoutFailure(
null == message ? _self.message : message // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

/// @nodoc


class BiometricLoading implements AuthState {
  const BiometricLoading();
  






@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is BiometricLoading);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'AuthState.biometricLoading()';
}


}




/// @nodoc


class BiometricSuccess implements AuthState {
  const BiometricSuccess();
  






@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is BiometricSuccess);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'AuthState.biometricSuccess()';
}


}




/// @nodoc


class BiometricFailure implements AuthState {
  const BiometricFailure(this.message);
  

 final  String message;

/// Create a copy of AuthState
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$BiometricFailureCopyWith<BiometricFailure> get copyWith => _$BiometricFailureCopyWithImpl<BiometricFailure>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is BiometricFailure&&(identical(other.message, message) || other.message == message));
}


@override
int get hashCode => Object.hash(runtimeType,message);

@override
String toString() {
  return 'AuthState.biometricFailure(message: $message)';
}


}

/// @nodoc
abstract mixin class $BiometricFailureCopyWith<$Res> implements $AuthStateCopyWith<$Res> {
  factory $BiometricFailureCopyWith(BiometricFailure value, $Res Function(BiometricFailure) _then) = _$BiometricFailureCopyWithImpl;
@useResult
$Res call({
 String message
});




}
/// @nodoc
class _$BiometricFailureCopyWithImpl<$Res>
    implements $BiometricFailureCopyWith<$Res> {
  _$BiometricFailureCopyWithImpl(this._self, this._then);

  final BiometricFailure _self;
  final $Res Function(BiometricFailure) _then;

/// Create a copy of AuthState
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? message = null,}) {
  return _then(BiometricFailure(
null == message ? _self.message : message // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

/// @nodoc


class ChangeIconVisibility implements AuthState {
  const ChangeIconVisibility(this.isPassword);
  

 final  bool isPassword;

/// Create a copy of AuthState
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$ChangeIconVisibilityCopyWith<ChangeIconVisibility> get copyWith => _$ChangeIconVisibilityCopyWithImpl<ChangeIconVisibility>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ChangeIconVisibility&&(identical(other.isPassword, isPassword) || other.isPassword == isPassword));
}


@override
int get hashCode => Object.hash(runtimeType,isPassword);

@override
String toString() {
  return 'AuthState.changeIconVisibility(isPassword: $isPassword)';
}


}

/// @nodoc
abstract mixin class $ChangeIconVisibilityCopyWith<$Res> implements $AuthStateCopyWith<$Res> {
  factory $ChangeIconVisibilityCopyWith(ChangeIconVisibility value, $Res Function(ChangeIconVisibility) _then) = _$ChangeIconVisibilityCopyWithImpl;
@useResult
$Res call({
 bool isPassword
});




}
/// @nodoc
class _$ChangeIconVisibilityCopyWithImpl<$Res>
    implements $ChangeIconVisibilityCopyWith<$Res> {
  _$ChangeIconVisibilityCopyWithImpl(this._self, this._then);

  final ChangeIconVisibility _self;
  final $Res Function(ChangeIconVisibility) _then;

/// Create a copy of AuthState
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? isPassword = null,}) {
  return _then(ChangeIconVisibility(
null == isPassword ? _self.isPassword : isPassword // ignore: cast_nullable_to_non_nullable
as bool,
  ));
}


}

/// @nodoc


class ChangeAppMode implements AuthState {
  const ChangeAppMode(this.isDark);
  

 final  bool isDark;

/// Create a copy of AuthState
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$ChangeAppModeCopyWith<ChangeAppMode> get copyWith => _$ChangeAppModeCopyWithImpl<ChangeAppMode>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ChangeAppMode&&(identical(other.isDark, isDark) || other.isDark == isDark));
}


@override
int get hashCode => Object.hash(runtimeType,isDark);

@override
String toString() {
  return 'AuthState.changeAppMode(isDark: $isDark)';
}


}

/// @nodoc
abstract mixin class $ChangeAppModeCopyWith<$Res> implements $AuthStateCopyWith<$Res> {
  factory $ChangeAppModeCopyWith(ChangeAppMode value, $Res Function(ChangeAppMode) _then) = _$ChangeAppModeCopyWithImpl;
@useResult
$Res call({
 bool isDark
});




}
/// @nodoc
class _$ChangeAppModeCopyWithImpl<$Res>
    implements $ChangeAppModeCopyWith<$Res> {
  _$ChangeAppModeCopyWithImpl(this._self, this._then);

  final ChangeAppMode _self;
  final $Res Function(ChangeAppMode) _then;

/// Create a copy of AuthState
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? isDark = null,}) {
  return _then(ChangeAppMode(
null == isDark ? _self.isDark : isDark // ignore: cast_nullable_to_non_nullable
as bool,
  ));
}


}

// dart format on
